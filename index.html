<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cognitive Map Experiment</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Cognitive Map Experiment</h1>
  <p>Drag each icon into the circle. You can reposition it by dragging it again.</p>

  <div id="pool">
    <!-- Icons pool with unique draggable images -->
    <img src="images/apple.png" class="draggable" alt="Apple">
    <img src="images/banana.png" class="draggable" alt="Banana">
    <img src="images/shoe.png" class="draggable" alt="Shoe">
    <!-- Add more icons as needed -->
  </div>

  <div id="circle"></div>

  <button onclick="saveMap()">Save Map</button>

  <script>
    const circle = document.getElementById('circle');
    const icons = document.querySelectorAll('.draggable');

    icons.forEach(icon => {
      icon.addEventListener('mousedown', (e) => {
        e.preventDefault();

        // Only start drag if the icon is still in the pool
        if (!icon.classList.contains('used')) {
          document.addEventListener('mousemove', onDrag);
          document.addEventListener('mouseup', onDrop);

          // Save the initial position of the mouse relative to the icon
          let offsetX = e.offsetX;
          let offsetY = e.offsetY;

          // Add a temporary class to the icon to indicate it's being moved
          icon.classList.add('moving');

          function onDrag(event) {
            icon.style.position = 'absolute';
            icon.style.left = `${event.pageX - offsetX}px`;
            icon.style.top = `${event.pageY - offsetY}px`;
          }

          function onDrop(event) {
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', onDrop);

            // Check if dropped in the circle
            const circleRect = circle.getBoundingClientRect();
            const iconRect = icon.getBoundingClientRect();

            if (
              iconRect.left >= circleRect.left &&
              iconRect.right <= circleRect.right &&
              iconRect.top >= circleRect.top &&
              iconRect.bottom <= circleRect.bottom
            ) {
              icon.classList.add('dropped-icon');
              icon.classList.add('used');  // Mark icon as used
              icon.classList.remove('moving');
              icon.draggable = true; // Make the icon draggable again for repositioning
              circle.appendChild(icon); // Move the icon to the circle
            } else {
              icon.style.position = '';
              icon.style.left = '';
              icon.style.top = '';
            }
          }
        }
      });
    });

    // Save the cognitive map data
    function saveMap() {
      const participantId = localStorage.getItem('participantId');
      const iconsData = [];

      // Collect the positions of the dropped icons inside the circle
      document.querySelectorAll('.dropped-icon').forEach(icon => {
        const rect = icon.getBoundingClientRect();
        const circleRect = circle.getBoundingClientRect();
        iconsData.push({
          icon: icon.src.split('/').pop(), // Extract the icon name (e.g., 'apple.png')
          x: rect.left - circleRect.left + rect.width / 2, // X position
          y: rect.top - circleRect.top + rect.height / 2  // Y position
        });
      });

      // Store the data in localStorage or send it to a backend
      localStorage.setItem('mapData', JSON.stringify({ participantId, iconsData }));

      // Confirm save action
      alert('Map saved! Your data has been saved successfully.');
    }
  </script>
</body>
</html>
